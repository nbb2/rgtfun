<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<title>Combined Document</title>
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:10px; font-family:Arial, Helvetica, sans-serif; font-size:14px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:14px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }

  </style>
</head>
<h1 id="introduction">Introduction</h1>
<p>In this documentation we will provide instructions on how to access
RGTFun, an example calculation using RGTFun that can be used as a
tutorial for new users, and then discuss the included testing suite.
Documentation for all functions can be found in the appendix.</p>
<h1 id="accessing-rgtfun">Accessing RGTFun</h1>
<p>RGTFun can be downloaded from the public Github repository linked
here:<br />
https://github.com/nbb2/rgtfun/tree/paper<br />
Please download all folders from the repository and ensure that they are
all located within a <em>RGTFun</em> folder on your machine (it does not
have to be called <em>RGTFun</em>). This is important because the app
will ask you to select the RGTFun folder on your machine so it can
establish the path to the <em>src</em> and <em>gui</em> folders. It does
not matter where your <em>RGTFun</em> folder is located as long as it is
a local folder, i.e. not in a cloud service. Once downloading the
repository folders, you can start the app by opening the
<em>gui.mlapp</em> file in the <em>gui</em> folder.</p>
<h1 id="an-example-calculation-of-argon-argon-interaction">An Example
Calculation of Argon-Argon Interaction</h1>
<p>We will now present example calculations of transport quanitities and
scattering integrals using RGTFun. The calculations will be performed
for an Argon-Argon ZBL potential.</p>
<h2 id="calculatefit-potential-tab">Calculate/Fit Potential Tab</h2>
<figure>
<img src="./figures/potentialtab.png" style="width:80.0%"
alt="Screenshot of Calculate/Fit Potential tab for an Argon-Argon ZBL potential. " />
<figcaption aria-hidden="true">Screenshot of <em>Calculate/Fit
Potential</em> tab for an Argon-Argon ZBL potential. </figcaption>
</figure>
<p>The <em>Calculate/Fit Potential</em> tab allows you to either create
your own potential data or fit one of the RGTFun-supported potentials to
your own data. For this example, we wanted to calculate a ZBL potential
for an Argon-Argon interaction. To begin, we selected “Calculate
Potential” from the “Selected Action” drop-down menu. Then, we selected
“ZBL” from the “Fit/Potential Type” drop-down menu. We then specified
the distance values and potential parameters. Then we selected the
folder where RGTFun will save the input/output files and data. We then
clicked “Write Input File” to generate an input file with the potential
parameters specified. This will auto populate the “Or Select Your Own
Input File” box. Lastly, we selected “Execute” to generate potential
data, plot the potential data, save the plot as an image, and save a fit
output file for the data.</p>
<h2 id="calculate-scattering-integrals-tab">Calculate Scattering
Integrals Tab</h2>
<figure>
<img src="./figures/scatteringtab.png" style="width:80.0%"
alt="Screenshot of Calculate Scattering Intergrals tab for an Argon-Argon ZBL potential. " />
<figcaption aria-hidden="true">Screenshot of <em>Calculate Scattering
Intergrals</em> tab for an Argon-Argon ZBL potential. </figcaption>
</figure>
<p>The <em>Calculate Scattering Integrals</em> tab allows you to
calculate the distance of closest approach (DOCA) and scattering angle
as a function of impact parameter. First, we chose “Numerical” from the
“Integral Type” drop down menu becuase we wanted to use our potential
data from the previous tab. We then specified the energy range for
calculating the quantities. Since we wanted log spacing for the energy
values, we clicked the “Log spacing” box and specifed the number of
points. Note that our fit output file was autopopulated after we clicked
“Execute” in the previous tab. We then specified the impact parameter
range to integrate over and chose to use log spacing for these values.
We then specified a range for the root solver used in the DOCA
calculations. We then clicked “Write Scattering Input File” to write the
input file and clicked “Execute” to generate datasets for the DOCA and
scattering angle, save those data sets to our “study” folder, and save
the figures as images.</p>
<h2 id="calculate-cross-sections-tab">Calculate Cross Sections Tab</h2>
<figure>
<img src="./figures/cstab.png" style="width:80.0%"
alt="Screenshot of Calculate Cross Sections tab for an Argon-Argon ZBL potential. " />
<figcaption aria-hidden="true">Screenshot of <em>Calculate Cross
Sections</em> tab for an Argon-Argon ZBL potential. </figcaption>
</figure>
<p>The <em>Calculate Cross Sections</em> tab allows you to calculate
total cross section, diffusion cross section, viscosity cross section,
and stopping cross section. First, we selected “Numerical” from the
“Integral Type” drop-down, which will use the scattering angle
vs. impact parameter data from the previous tab. While the energy values
from the previous tab autopopulate into this tab, we have increased the
number of energy points from what was used in figure 7 to reduce error
in the trapezoidal integrals used in this tab. We then specified the
atomic mass of Argon in atomic units. Note that the file path of the
scattering angle data was autopopulated when the previous tab was
executed. Then we chose to use a quantum mechanical cutoff for the total
cross section. Then, we clicked “Write CS Input File” to create the
input file for the cross section calculations. Lastly, we clicked
“Execute” to calculate the cross sections, save the data as csv files in
our “study folder”, and save the figures as images.</p>
<h2 id="calculate-transport-coefficients-tab">Calculate Transport
Coefficients Tab</h2>
<figure>
<img src="./figures/transporttab.png" style="width:80.0%"
alt="Screenshot of Calculate Transport Coefficients tab for an Argon-Argon ZBL potential. " />
<figcaption aria-hidden="true">Screenshot of <em>Calculate Transport
Coefficients</em> tab for an Argon-Argon ZBL potential. </figcaption>
</figure>
<p>The tab allows you to calculate the self-diffusion coefficient and
viscosity coefficient for user-specified temperatures. First, we
selected “Numerical” from the “Integration Type” drop down, which allows
us to use the cross section data from the previous tab. Next, we
specified the temperature range (in Kelvin) that the code should use to
calculate the transport coefficient data. Note that the atomic masses of
the present species, as well as the locations of the cross section data
files, were autopopulated from the previous tab. We then clicked “Write
Transport Input File” to write the input file to our “study” folder.
Lastly, we clicked “Execute” to calculate the self-diffusion and
viscosity coefficient data, save the data as csv files in our “study”
folder, plot the data, and save the plots as images.</p>
<h2 id="calculate-dsmc-coefficients-tab">Calculate DSMC Coefficients
Tab</h2>
<figure>
<img src="./figures/dsmctab.png" style="width:80.0%"
alt="Screenshot of Calculate DSMC Coefficients tab for an Argon-Argon ZBL potential. " />
<figcaption aria-hidden="true">Screenshot of <em>Calculate DSMC
Coefficients</em> tab for an Argon-Argon ZBL potential. </figcaption>
</figure>
<p>The <em>Calculate DSMC Coefficients</em> tab allows the user to
calculate the <span class="math inline"><em>ω</em></span> parameter for
the VHS DSMC model. This parameter is calculated by fitting the VHS
diffusion coefficient expression to the user-provided viscosity
coefficient data. Note that the location of our viscosity coefficient
data file was autopopulated upon execution of the previous tab. Next, we
specifed the number of subintervals to split the data into for fitting.
An <span class="math inline"><em>ω</em></span> parameter will be
calculated for each subinterval. We also specifed the tolerance for the
fitting. A tolerance of 1e-12 or lower is suggested. Note that the
atomic masses of the present species were autopopulated from the
previous tab. We then clicked “Write DSMC Input File” to write the input
file to our “study folder”. Lastly, we clicked “Execute” to calculate an
<span class="math inline"><em>ω</em></span> parameter for each
subinterval of our viscosity coefficient data, as well as a collision
diameter for each subinterval. Our viscosity coefficient data from the
previous tab and the fitted subintervals are plotted. All relevant
quantities are visible in the tab’s table. This table is saved to our
“study” folder.</p>
<h1 id="rgtfun-test-suite">RGTFun Test Suite</h1>
<p>A test suite has been included in the main RGTFun distribution so
that users can verify their version is functioning correctly. Test
functions were written to verify the functionality of all main functions
within RGTFun. The test functions are located in the <em>test</em>
folder within the main <em>RGTFun</em> folder. All test reference data
is located in the <em>testFiles</em> folder. To run the tests, please
change directories to the <em>test</em> folder and load the test
functions in the MATLAB Test Browser. Then run the current suite, and
verify that all tests were executed successfully.</p>

<h1 id="chebfun dependence">Chebfun Dependence</h1>
<p>RGTFun utilized the advanced root-finding capabilities of the Chebfun matlab package. Thus, in order to run RGTFun, Chebfun must be installed.</p>

<h1 id="Appendix: Function Documentation">Appendix:Function Documentation</h1>
<body><div class="content"><h1>Table of Contents</h1><ul><li><a href="#DOCAroot">DOCAroot</a></li><li><a href="#GMquadScatteringAngle">GMquadScatteringAngle</a></li><li><a href="#VHScoef">VHScoef</a></li><li><a href="#VHSviscosity">VHSviscosity</a></li><li><a href="#VSSalpha">VSSalpha</a></li><li><a href="#VSScoef">VSScoef</a></li><li><a href="#VSSconvergence">VSSconvergence</a></li><li><a href="#VSSdiameter">VSSdiameter</a></li><li><a href="#VSSdiffusion">VSSdiffusion</a></li><li><a href="#coulomb">coulomb</a></li><li><a href="#coulombchar">coulombchar</a></li><li><a href="#diffusion_coef">diffusion_coef</a></li><li><a href="#diffusioncs">diffusioncs</a></li><li><a href="#difscatter">difscatter</a></li><li><a href="#distclose">distclose</a></li><li><a href="#impact">impact</a></li><li><a href="#lj_124">lj_124</a></li><li><a href="#lj_126">lj_126</a></li><li><a href="#magicscatter">magicscatter</a></li><li><a href="#morse">morse</a></li><li><a href="#numdiffusioncoef">numdiffusioncoef</a></li><li><a href="#numdiffusioncs">numdiffusioncs</a></li><li><a href="#numstoppingcs">numstoppingcs</a></li><li><a href="#numtotalcs">numtotalcs</a></li><li><a href="#numtotalcscheb">numtotalcscheb</a></li><li><a href="#numvisccoef">numvisccoef</a></li><li><a href="#numvisccs">numvisccs</a></li><li><a href="#powerlaw">powerlaw</a></li><li><a href="#run_calcpotential">run_calcpotential</a></li><li><a href="#run_dsmccoef">run_dsmccoef</a></li><li><a href="#run_fitpotential">run_fitpotential</a></li><li><a href="#run_scatteringintegrals">run_scatteringintegrals</a></li><li><a href="#run_transportCS">run_transportCS</a></li><li><a href="#run_transportcoefs">run_transportcoefs</a></li><li><a href="#run_vhscoef">run_vhscoef</a></li><li><a href="#run_vsscoef">run_vsscoef</a></li><li><a href="#visc_coef">visc_coef</a></li><li><a href="#viscositycs">viscositycs</a></li><li><a href="#zbl">zbl</a></li><li><a href="#zblchar">zblchar</a></li><li><a href="#zblderivative">zblderivative</a></li></ul></div>
<h1 id="DOCAroot" style="margin-left: 20px;">DOCAroot</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> r0 = DOCAroot(Ec,b,V,rmin,rmax,chebfunpath)
<span class="comment">%DOCAROOT    Outputs float value for the root of the DOCA equation.</span>
<span class="comment">%   Y=DOCAROOT(EC,B,V,RMIN,RMAX) generates a float value for the root</span>
<span class="comment">%   of the distance of closest approach (DOCA) equation using two</span>
<span class="comment">%   iterations of the CHEBFUN root finding package.</span>
<span class="comment">%</span>
<span class="comment">%   -- EC must be the the energy in eV.</span>
<span class="comment">%   -- B must be the impact paramter in Angstrom.</span>
<span class="comment">%   -- V must be the potential function handle.</span>
<span class="comment">%   -- RMIN is the lower bound of possible root values in Angstrom.</span>
<span class="comment">%   -- RMAX is the upper bound of possble root values in Angstrom.</span>
<span class="comment">%</span>
<span class="comment">%   See also GMQUADSCATTERINGANGLE RUN_SCATTERINGINTEGRALS</span>
    addpath(chebfunpath)
    chebDOCA = chebfun(@(r) doca(r,Ec,b,V),[rmin,rmax]);
    ri = max(roots(chebDOCA));
    chebDOCA2 = chebfun(@(r) doca(r,Ec,b,V),[0.9*ri,1.1*ri]);
    r0 = max(roots(chebDOCA2));

<span class="keyword">end</span>

<span class="keyword">function</span> d = doca(r,Ec,b,V)
<span class="comment">%MY_DOCA Ouputs the DOCA equation.</span>
<span class="comment">%   Y=MY_DOCA(R,EC,B,V) generates the DOCA equation.</span>
<span class="comment">%   -- R is a placeholder value for distance.</span>
<span class="comment">%   -- EC must be the energy in eV.</span>
<span class="comment">%   -- B must be the impact parameter in Angstrom.</span>
<span class="comment">%   -- V is the potential function handle.</span>
<span class="comment">%</span>
<span class="comment">%   See also DOCAROOT</span>
    d = r^2 - ((r^2)*V(r)/Ec) - (b^2);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="GMquadScatteringAngle" style="margin-left: 20px;">GMquadScatteringAngle</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> th = GMquadScatteringAngle(V,Ec,b,rm,n)
<span class="comment">%GMQUADSCATTERINGANGLE    Outputs float scattering angle.</span>
<span class="comment">%   Y=GMQUADSCATTERINGANGLE(V,EC,B,RM,N) generates a float value for the</span>
<span class="comment">%   scattering angle using GM Quadrature.</span>
<span class="comment">%</span>
<span class="comment">%   -- V must be the potential function handle.</span>
<span class="comment">%   -- EC must be the the energy in eV.</span>
<span class="comment">%   -- B must be the impact paramter in Angstrom.</span>
<span class="comment">%   -- RM is the distance of closest approach in Angstrom.</span>
<span class="comment">%   -- N is the number of trapezoids to use.</span>
<span class="comment">%</span>
<span class="comment">%   See also DOCAROOT RUN_SCATTERINGINTEGRALS</span>
    sum = 0;
    <span class="keyword">for</span> j = 1:(n/2)
        anj = cos(((2*((n/2) - j + 1) - 1)/(2*n))*pi);
        aj = cos(((2*j - 1)/(2*n))*pi);
        gj = (   1 - (V(rm/aj)/Ec) - ((b^2 * aj^2)/(rm^2)))^(-1/2);
        sum = sum + (anj * gj);
    <span class="keyword">end</span>
    th = pi * (1 - ((2*b*sum)/(n*rm)));
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="VHScoef" style="margin-left: 20px;">VHScoef</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = VHScoef(fitT,T_sample,mu_sample,excludeT,vq,tol)
<span class="comment">%VHSCOEF  Outputs sample visc value and VHS param.</span>
<span class="comment">%   Y=VHSCOEF(FITT,T_SAMPLE,EXCLUDET,VQ,TOL) outputs a reference</span>
<span class="comment">%   viscosity value and VHS parameter omega by fitting the VHS model to</span>
<span class="comment">%   user-specified visocity coefficient data.</span>
<span class="comment">%</span>
<span class="comment">%   -- FITT must be the interpolated temperature values in K.</span>
<span class="comment">%   -- T_SAMPLE must be the reference temperature value.</span>
<span class="comment">%   -- EXCLUDET must be a logical array of what temp values to use.</span>
<span class="comment">%   -- VQ must be the interpolated viscosity coefficient values with the</span>
<span class="comment">%   same dimension as FITT.</span>
<span class="comment">%   -- TOL must be the fitting tolerance.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_DSMCCOEF</span>
fitcoef = vq;
fitcoef(excludeT) = [];
fitchar = sprintf(<span class="string">"(%f)*(T/(%f)).^(a)"</span>,mu_sample,T_sample);
ft = fittype(fitchar,dependent=<span class="string">"y"</span>,<span class="keyword">...</span>
        independent=<span class="string">"T"</span>,coefficients=<span class="string">"a"</span>);
coeffit = fit(fitT',fitcoef',ft,<span class="string">'TolFun'</span>,tol);
omega = coeffvalues(coeffit);
y = [mu_sample,omega];
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="VHSviscosity" style="margin-left: 20px;">VHSviscosity</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = VHSviscosity(T,omega,T_ref,mu_ref)
<span class="comment">%VHSVISCOSITY  Outputs float array with viscosity coefficient values.</span>
<span class="comment">%   Y=VHSVISCOSITY(T,OMEGA,T_REF,MU_REF) generates a float array</span>
<span class="comment">%   containing viscosity coefficient value for each value of T using the</span>
<span class="comment">%   VHS model.</span>
<span class="comment">%</span>
<span class="comment">%   -- T must be a float array of temperature values in K.</span>
<span class="comment">%   -- OMEGA must be the VHS parameter.</span>
<span class="comment">%   -- T_REF must be the reference temp in K.</span>
<span class="comment">%   -- MU_REF must be the reference viscosity value.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_DSMCCOEF</span>
y = mu_ref*(T/T_ref).^omega;
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="VSSalpha" style="margin-left: 20px;">VSSalpha</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = VSSalpha(omegavals,m,molar,Tvals,difvals,diams)
<span class="comment">%VSSALPHA  Outputs VSS param alpha.</span>
<span class="comment">%   Y=VSSALPHA(OMEGAVALS,M,MOLAR,TVALS,DIFVALS,DIAMS) outputs VSS parameter</span>
<span class="comment">%   alpha using reference diffusion coefficient and collision diameter data.</span>
<span class="comment">%</span>
<span class="comment">%   -- OMEGAVALS must be an array of reference omega values.</span>
<span class="comment">%   -- M must be the mass of a particle in kg.</span>
<span class="comment">%   -- MOLAR must be the molar mass in kg.</span>
<span class="comment">%   -- TVALS must be an array of the reference temperature values in K.</span>
<span class="comment">%   -- DIFVALS must be an array of the reference diffusion coefficient data.</span>
<span class="comment">%   -- DIAMS must be an array of the reference collision diameteres in angstrom.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_VSSCOEF</span>
kb = 1.380649E-23; <span class="comment">%J/K</span>
Na = 6.022E23;
rhoD = molar*difvals./(Na*kb*Tvals);
y = ((4*(5-2*omegavals).*rhoD.*(diams.^2))./(3*sqrt(m*kb*Tvals/pi))) - 1;
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="VSScoef" style="margin-left: 20px;">VSScoef</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = VSScoef(minT,maxT,Tfine,vq,m,omega,P,tol)
<span class="comment">%VSSCOEF  Outputs VSS params alpha and d.</span>
<span class="comment">%   Y=VSSCOEF(MINT,MAXT,TFINE,VQ,M,OMEGA,P,TOL) outputs VSS parameters</span>
<span class="comment">%   alpha and d by fitting the VSS model to user-specified diffusin</span>
<span class="comment">%   coefficient data.</span>
<span class="comment">%</span>
<span class="comment">%   -- MINT must be the lower bound of the temp range in K.</span>
<span class="comment">%   -- MAXT mut be the upper bound of the temp range in K.</span>
<span class="comment">%   -- TFINE must be the interpolated temperature values in K.</span>
<span class="comment">%   -- VQ must be the interpolated diffusion coefficient values with the</span>
<span class="comment">%   same dimension as TFINE.</span>
<span class="comment">%   -- M must be the reduced mass of the system in amu.</span>
<span class="comment">%   -- OMEGA must be the VHS param.</span>
<span class="comment">%   -- TOL must be the fitting tolerance.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_DSMCCOEF</span>
kb = 8.617333262E-5; <span class="comment">%eV/K</span>
excludeT = ((Tfine &lt; minT) | (Tfine &gt; maxT));
fitcoef = vq;
fitT = Tfine;
fitT(excludeT) = [];
fitcoef(excludeT) = [];
T_sample = 0.5*(minT + maxT);
cref = 2*(2.5-omega)*kb*T_sample/m;
fitchar = sprintf(<span class="string">"157377.3718*30000*(a+1)*(pi^0.5)*((%e)*T).*((pi*2*(%e)*T/(%e)).^(%e))/(16*a*gamma(3.5-%e)*(%e)*pi*(d^2)*(%e)^((%e) - 1/2))"</span>,<span class="keyword">...</span>
    kb,kb,m,omega,omega,P,cref,omega);
ft = fittype(fitchar,dependent=<span class="string">"y"</span>,<span class="keyword">...</span>
        independent=<span class="string">"T"</span>,coefficients=[<span class="string">"a"</span> <span class="string">"d"</span>]);
coeffit = fit(fitT',fitcoef',ft,<span class="string">'TolFun'</span>,tol,<span class="string">'Lower'</span>,[0 0],<span class="keyword">...</span>
                    <span class="string">'Upper'</span>,[10 10],<span class="string">'StartPoint'</span>,[1 1]);
coefs = coeffvalues(coeffit);
alpha = coefs(1);
d = coefs(2);
y = [alpha,d];
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="VSSconvergence" style="margin-left: 20px;">VSSconvergence</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = VSSconvergence(alphavals,omegavals,m,Tvals,difvals,muref,tol)
<span class="comment">%VSSCONVERGENCE  Checks least squares convergence of VSS parameters.</span>
<span class="comment">%   Y=VSSCONVERGENCE(ALPHAVALS,OMEGAVALS,M,TVALS,DIFVALS,MUREF,TOL) outputs</span>
<span class="comment">%   TRUE or FALSE depending on if the user-specified least-squares</span>
<span class="comment">%   tolerance is satisfied.</span>
<span class="comment">%</span>
<span class="comment">%   -- ALPHAVALS must be an array of the alpha values at each reference temperature.</span>
<span class="comment">%   -- OMEGAVALS must be an array of the omega values at each reference</span>
<span class="comment">%   temperature.</span>
<span class="comment">%   -- M must be the mass of a particle in kg.</span>
<span class="comment">%   -- TVALS must be an array of the reference temperature values in K.</span>
<span class="comment">%   -- DIFVALS must be an array of the reference diffusion coefficient data.</span>
<span class="comment">%   -- MUREF must be an array of the reference viscosity coefficient data.</span>
<span class="comment">%   -- TOL must be the user-specified least squares tolerance.</span>
<span class="comment">%   See also RUN_VSSCOEF</span>
kb = 1.380649E-23; <span class="comment">%J/K</span>
Na = 6.022E23;
rhoD = m*difvals./(Na*kb*Tvals);
muvals = ((10./alphavals)+5).*rhoD./(21-6*omegavals);
Sc = rhoD./muref; <span class="comment">%Schmidt number</span>
LSerror = sum((muvals - muref).^2);
y = (LSerror &gt; tol);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="VSSdiameter" style="margin-left: 20px;">VSSdiameter</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = VSSdiameter(alphavals,omegavals,m,Tvals,muvals)
<span class="comment">%VSSDIAMETER  Outputs VSS collision diameter.</span>
<span class="comment">%   Y=VSSDIAMETER(ALPHAVALS,OMEGAVALS,M,TVALS,MUVALS) outputs VSS collision</span>
<span class="comment">%   diamater using reference viscosity coefficient and VHS parameter data.</span>
<span class="comment">%</span>
<span class="comment">%   -- ALPHAVALS must be an array of the alpha values at each reference temperature.</span>
<span class="comment">%   -- OMEGAVALS must be an array of reference omega values.</span>
<span class="comment">%   -- M must be the mass of a particle in kg.</span>
<span class="comment">%   -- TVALS must be an array of the reference temperature values in K.</span>
<span class="comment">%   -- MUVALS must be an array of the reference viscosity coefficient data.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_VSSCOEF</span>
kb = 1.380649E-23; <span class="comment">%J/K</span>
y2 = ((5*(alphavals+1).*(alphavals+2).*sqrt(m*kb*Tvals/pi))./<span class="keyword">...</span>
    (4*alphavals.*(5-2*omegavals).*(7-2*omegavals).*muvals)); <span class="comment">% meters</span>
y = sqrt(y2);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="VSSdiffusion" style="margin-left: 20px;">VSSdiffusion</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = VSSdiffusion(T,omega,a,d,m,P,T_sample)
<span class="comment">%MY_VSSDIFFUSION  Outputs float array with diffusion coefficient values.</span>
<span class="comment">%   Y=MY_VSSDIFFUSION(T,OMEGA,A,D,M,P,T_SAMPLE) generates a float array</span>
<span class="comment">%   containing diffusion coefficient value for each value of T using the</span>
<span class="comment">%   VSS model.</span>
<span class="comment">%</span>
<span class="comment">%   -- T must be a float array of temperature values in K.</span>
<span class="comment">%   -- OMEGA must be the VHS parameter.</span>
<span class="comment">%   -- A must be the alpha VSS parameter.</span>
<span class="comment">%   -- D must be the d VSS parameter.</span>
<span class="comment">%   -- M must be the reduced mass in amu.</span>
<span class="comment">%   -- P must be the pressure in bar.</span>
<span class="comment">%   -- T_SAMPLE must be the reference temp in K.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_DSMCCOEF</span>
<span class="comment">%kb = 1.380649E-23; %J/K</span>
kb = 8.617333262E-5; <span class="comment">%eV/K</span>
cref = 2*(2.5-omega)*kb*T_sample/m;
fprintf(<span class="string">'cref is %f\n'</span>,cref)
y = 157377.3718*30000*(a+1)*(pi^0.5)*(kb*T).*((pi*2*kb*T/m).^omega)/(16*a*gamma(3.5-omega)*<span class="keyword">...</span>
    P*pi*(d^2)*(cref)^(omega - 0.5));
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
<br/>
</p>
</div><hr/><h1 id="coulomb" style="margin-left: 20px;">coulomb</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = coulombchar(z1)
<span class="comment">%COULOMBCHAR    Outputs character array with fitting model.</span>
<span class="comment">%   Y=COULOMBCHAR(Z1) generates a char array containing</span>
<span class="comment">%   the Coulomb potential equation with the user-specified Z1.</span>
<span class="comment">%</span>
<span class="comment">%   -- Z1 must be the integer atomic number of species 1.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_FITPOTENTIAL</span>
    eps_naught = 0.005526349406; <span class="comment">%e^2 * eV^-1 * Angstrom^-1</span>
    Ke = 1/(4*pi*eps_naught);
    y = sprintf(<span class="string">"(%d)*%i*z2./x"</span>,Ke,z1);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="coulombchar" style="margin-left: 20px;">coulombchar</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = coulombchar(z1)
<span class="comment">%COULOMBCHAR    Outputs character array with fitting model.</span>
<span class="comment">%   Y=COULOMBCHAR(Z1) generates a char array containing</span>
<span class="comment">%   the Coulomb potential equation with the user-specified Z1.</span>
<span class="comment">%</span>
<span class="comment">%   -- Z1 must be the integer atomic number of species 1.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_FITPOTENTIAL</span>
    eps_naught = 0.005526349406; <span class="comment">%e^2 * eV^-1 * Angstrom^-1</span>
    Ke = 1/(4*pi*eps_naught);
    y = sprintf(<span class="string">"(%d)*%i*z2./x"</span>,Ke,z1);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="diffusion_coef" style="margin-left: 20px;">diffusion_coef</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = diffusion_coef(well_depth,T,m1,m2,d,inttype,data)
<span class="comment">%DIFFUSION_COEF    Outputs self-diffusion coefficient.</span>
<span class="comment">%   Y=DIFFUSION_COEF(WELL_DEPTH,T,P,M1,M2,D,INTTYPE,DATA) generates a float</span>
<span class="comment">%   array containing a self-diffusion coefficient value for each temperature</span>
<span class="comment">%   using a Lennard_Jones potential (from "Khrapak, S.A. Accurate transport</span>
<span class="comment">%   cross sections for the Lennard-Jones potential. Eur. Phys. J. D 68, 276</span>
<span class="comment">%   (2014)"). Units of self-diffusion coefficient are cm^2 /s.</span>
<span class="comment">%</span>
<span class="comment">%   -- WELL-DEPTH must be the LJ well-depth in Kelvin.</span>
<span class="comment">%   -- T must be a float array containing temperature values in units of K.</span>
<span class="comment">%   -- P must be the pressure in bar.</span>
<span class="comment">%   -- M1 must be the mass of species 1 in amu.</span>
<span class="comment">%   -- M2 must be the mass of species 2 in amu.</span>
<span class="comment">%   -- D must be the sigma LJ parameter in units of Angstrom.</span>
<span class="comment">%   -- INTTYPE must be a character string specifying if the integral will</span>
<span class="comment">%   be exact or numerical.</span>
<span class="comment">%   -- DATA must be a character string filepath that gives the location of</span>
<span class="comment">%   the cross section data.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_TRANSPORTCS</span>
Tjoul = T.*(1.380649e-23);
mu = (m1*m2)/(m1+m2);
mukg = mu*(1.66054e-27);
dm = d*(1e-10);
Tstar = T/well_depth;
<span class="keyword">if</span> strcmp(inttype,<span class="string">'Exact LJ'</span>)
    y = (3*sqrt(2*pi)/16)*((Tjoul).^(3/2))./(((mukg)^(1/2))* <span class="keyword">...</span>
    ((dm)^2)*reduceddifint(Tstar)); <span class="comment">%PD in units of Pa * m^2 / s</span>
<span class="keyword">elseif</span> strcmp(inttype,<span class="string">'Trapezoidal LJ'</span>)
    y = (3*sqrt(2*pi)/16)*((Tjoul).^(3/2))./(((mukg)^(1/2))* <span class="keyword">...</span>
    ((dm)^2)*reduceddifquad(Tstar,data)); <span class="comment">%PD in units of Pa * m^2 / s</span>
<span class="keyword">else</span>
    disp(<span class="string">'Invalid Integration Type. Please check input file and try again.'</span>)
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> y = reduceddifint(Tstar)
<span class="comment">%REDUCEDDIFINT    Outputs the reduced diffusion integral.</span>
<span class="comment">%   Y=REDUCEDDIFINT(TSTAR) generates a float array containing a value</span>
<span class="comment">%   for the exact reduced diffusion integral in Khrapak, S.A. Accurate transport</span>
<span class="comment">%   cross sections for the Lennard-Jones potential (2014).</span>
<span class="comment">%</span>
<span class="comment">%   -- TSTAR is  float array containing the reduced temperature values.</span>
y = zeros(size(Tstar));
ct = 1;
<span class="keyword">for</span> t = Tstar
reddifintegrand = @(x) 0.5*(x.^2).*exp(-x).*diffusioncs(1./(2*t*x));
y(ct) = integral(reddifintegrand,0,Inf);
ct = ct + 1;
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> y = reduceddifquad(Tstar,data)
<span class="comment">%REDUCEDDIFQUAD    Outputs the reduced diffusion integral using quadrature.</span>
<span class="comment">%   Y=REDUCEDDIFQUAD(TSTAR,DATA) generates a float array containing a value</span>
<span class="comment">%   for the reduced diffusion integral in Khrapak, S.A. Accurate transport</span>
<span class="comment">%   cross sections for the Lennard-Jones potential (2014) using trapezoidal</span>
<span class="comment">%   integration.</span>
<span class="comment">%</span>
<span class="comment">%   -- TSTAR is  float array containing the reduced temperature values.</span>
<span class="comment">%   -- DATA is a char array containing the filepath of the cross-section</span>
<span class="comment">%   data.</span>
y = zeros(size(Tstar));
ct = 1;
csdata = readmatrix(data);
<span class="keyword">for</span> t = Tstar
X = 1./(2*t*csdata(:,1));
reddifintegrand = -0.25*(X.^2).*exp(-X).*csdata(:,2)./(t*csdata(:,1).^2);
y(ct) = trapz(csdata(:,1),reddifintegrand);
ct = ct + 1;
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="diffusioncs" style="margin-left: 20px;">diffusioncs</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = diffusioncs(beta)
<span class="comment">%DIFFUSIONCS    Outputs float array with diffusion cross-section values.</span>
<span class="comment">%   Y=DIFFUSIONCS(BETA) generates a float array containing diffusion</span>
<span class="comment">%   cros-section value for each value of the scattering parameter beta</span>
<span class="comment">%   using a Lennard_Jones potential.</span>
<span class="comment">%</span>
<span class="comment">%   -- BETA must be a float array containing values for the dimensionless</span>
<span class="comment">%   scattering parameter.</span>
<span class="comment">%</span>
<span class="comment">%   See also VISCOSITYCS RUN_TRANSPORTCS</span>
fLEd = 1 - 0.019.*(beta.^(-1)) + 0.038.*(beta.^(-2)) - 0.049.*(beta.^(-3)) <span class="keyword">...</span>
    + 0.015.*(beta.^(-4));
fHEd = 1 - 0.692.*(beta) + 9.594.*(beta.^(2)) - 8.284.*(beta.^(3)) <span class="keyword">...</span>
    - 2.355.*(beta.^(4));

y = zeros(size(beta));
<span class="comment">%%Case 1: beta &lt; 0.506</span>
idx1 = beta &lt; 0.506;
y(idx1) = 4.507.*(beta(idx1).^(1/6)).*fHEd(idx1);

<span class="comment">%%Case 2: beta &gt; 0.506</span>
idx2 = beta &gt; 0.506;
y(idx2) = 9.866.*(beta(idx2).^(1/3)).*fLEd(idx2);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="difscatter" style="margin-left: 20px;">difscatter</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = difscatter(z1,z2,theta,E)
<span class="comment">%DIFSCATTER    Outputs differential scattering cross section.</span>
<span class="comment">%   Y=DIFSCATTER(Z1,Z2,THETA,E) generates a float array containing</span>
<span class="comment">%   a differential scattering cross section value for each scattering</span>
<span class="comment">%   angle using the Rutherford scattering model. Units of differential</span>
<span class="comment">%   scattering cross section are Angstrom^2 / sr.</span>
<span class="comment">%</span>
<span class="comment">%   -- Z1 must be the integer atomic number of species 1.</span>
<span class="comment">%   -- Z2 must be the integer atomic number of species 2.</span>
<span class="comment">%   -- THETA must be the float array containing scattering angle values in</span>
<span class="comment">%   units of radians.</span>
<span class="comment">%   -- E must be the incident energy as numeric char in units of eV.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_SCATTERINGINTEGRALS</span>
    eps_naught = 0.005526349406; <span class="comment">%e^2 * eV^-1 * Angstrom^-1</span>
    Ke = 4*pi*eps_naught;
    y = (z1*z2./(4*Ke*E.*sin(theta/2).^2)).^2;
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="distclose" style="margin-left: 20px;">distclose</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = distclose(z1,z2,b,E)
<span class="comment">%DISTCLOSE    Outputs distance of closest approach.</span>
<span class="comment">%   Y=DISTCLOSE(Z1,Z2,B,E) generates a float array containing an</span>
<span class="comment">%   impact parameter value for each scattering angle using the</span>
<span class="comment">%   Rutherford scattering model. Units of distance of closest approach</span>
<span class="comment">%   are Angstroms.</span>
<span class="comment">%</span>
<span class="comment">%   -- Z1 must be the integer atomic number of species 1.</span>
<span class="comment">%   -- Z2 must be the integer atomic number of species 2.</span>
<span class="comment">%   -- B must be the float array containing impact parameter values in</span>
<span class="comment">%   units of Angstroms.</span>
<span class="comment">%   -- E must be the incident energy as numeric char in units of eV.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_SCATTERINGINTEGRALS</span>
    eps_naught = 0.005526349406; <span class="comment">%e^2 * eV^-1 * Angstrom^-1</span>
    Ke = 1/(4*pi*eps_naught);
    gamma = (Ke*z1*z2/E);
    y = 0.5*(gamma+sqrt(gamma^2 + 4*(b.^2)));
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="impact" style="margin-left: 20px;">impact</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = impact(z1,z2,theta,E)
<span class="comment">%IMPACT    Outputs impact parameter.</span>
<span class="comment">%   Y=IMPACT(Z1,Z2,THETA,E) generates a float array containing an</span>
<span class="comment">%   impact parameter value for each scattering angle using the</span>
<span class="comment">%   Rutherford scattering model. Units of impact parameter are Angstrom.</span>
<span class="comment">%</span>
<span class="comment">%   -- Z1 must be the integer atomic number of species 1.</span>
<span class="comment">%   -- Z2 must be the integer atomic number of species 2.</span>
<span class="comment">%   -- THETA must be the float array containing scattering angle values in</span>
<span class="comment">%   units of radians.</span>
<span class="comment">%   -- E must be the incident energy as numeric char in units of eV.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_SCATTERINGINTEGRALS</span>
    eps_naught = 0.005526349406; <span class="comment">%e^2 * eV^-1 * Angstrom^-1</span>
    Ke = 4*pi*eps_naught;
    y = z1*z2.*cot(theta/2)./(2*Ke*E);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="lj_124" style="margin-left: 20px;">lj_124</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = lj_124(eps_well,sig,r)
<span class="comment">%LJ_124    Outputs Lennard Jones potential data.</span>
<span class="comment">%   Y=LJ_124(EPS_WELL,SIG,R) generates a float array containing</span>
<span class="comment">%   a potential energy value for each r value using the 12-4 Lennard Jones</span>
<span class="comment">%   potential. Units of potential energy are eV.</span>
<span class="comment">%</span>
<span class="comment">%   -- EPS_WELL must be the float LJ well depth.</span>
<span class="comment">%   -- SIGMA must be the float distance at which the potential is zero.</span>
<span class="comment">%   -- R must be the numerical array containing r values in units of</span>
<span class="comment">%   Angstrom.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_CALCPOTENTIAL</span>
    y = (0.5)*(3^1.5)*eps_well*(((sig./r).^12)-((sig./r).^4));
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="lj_126" style="margin-left: 20px;">lj_126</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = lj_126(eps_well,sig,r)
<span class="comment">%LJ_126    Outputs Lennard Jones potential data.</span>
<span class="comment">%   Y=LJ_126(EPS_WELL,SIG,R) generates a float array containing</span>
<span class="comment">%   a potential energy value for each r value using the 12-6 Lennard Jones</span>
<span class="comment">%   potential. Units of potential energy are eV.</span>
<span class="comment">%</span>
<span class="comment">%   -- EPS_WELL must be the float LJ well depth.</span>
<span class="comment">%   -- SIGMA must be the float distance at which the potential is zero.</span>
<span class="comment">%   -- R must be the numerical array containing r values in units of</span>
<span class="comment">%   Angstrom.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_CALCPOTENTIAL</span>
    y = 4*eps_well*(((sig./r).^12)-((sig./r).^6));
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="magicscatter" style="margin-left: 20px;">magicscatter</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> th = magicscatter(Ec,b,V,rm,z1,z2)
<span class="comment">%MAGICSCATTER   Outputs float value for the scattering angle from the Magic Formula.</span>
<span class="comment">%   Y=MAGICSCATTER(EC,B,V,RMIN,Z1,Z2) generates a float value for the</span>
<span class="comment">%   scattering angle using the Magic Formula.</span>
<span class="comment">%</span>
<span class="comment">%   -- EC must be the the energy in eV.</span>
<span class="comment">%   -- B must be the impact parameter in Angstrom.</span>
<span class="comment">%   -- V must be the potential function handle.</span>
<span class="comment">%   -- RMIN is the distance of closest approach in Angstrom.</span>
<span class="comment">%   -- Z1 is the atomic number of species 1.</span>
<span class="comment">%   -- Z2 is the atomic number of species 2.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_SCATTERINGINTEGRALS</span>
    m1 = 1.008; <span class="comment">%this needs to be updated for each run!!</span>
    m2 = 1.008; <span class="comment">%this needs to be updated for each run!!</span>
    a = (0.46850)/(z1^(0.23) + z2^(0.23));
    epschar = (a*Ec)/(z1*z2*14.4);
    Vprmin = zblderivative(z1,z2,rm);
    thArg = (Bvar(b,a) + Rcvar(rhovar(Ec,V(rm),Vprmin),a) +  <span class="keyword">...</span>
        Deltavar(epschar,Bvar(b,a),R0var(rm,a)))/(R0var(rm,a) + Rcvar(rhovar(Ec,V(rm),Vprmin),a));
    th = 2*acos(thArg);
    disp(th)
<span class="keyword">end</span>

<span class="keyword">function</span> y = Bvar(b,a)
    y = b/a;
<span class="keyword">end</span>

<span class="keyword">function</span> y = Rcvar(rhovar,a)
    y = rhovar/a;
<span class="keyword">end</span>

<span class="keyword">function</span> y = rhovar(E,Vrmin,Vprmin)
    y = -2*(E-Vrmin)/Vprmin;
<span class="keyword">end</span>

<span class="keyword">function</span> y = R0var(rmin,a)
    y = rmin/a;
<span class="keyword">end</span>

<span class="keyword">function</span> y = Deltavar(epschar,Bvar,R)
    C1 = 0.9923;
    C2 = 0.01162;
    C3 = 0.007122;
    C4 = 9.307;
    C5 = 14.81;
    alpha = 1 + C1/sqrt(epschar);
    beta = (C2 + sqrt(epschar))/(C3 + sqrt(epschar));
    A =2*alpha*epschar*(Bvar^beta);
    gammavar = (C4 + epschar)/(C5 + epschar);
    G = gammavar/(sqrt(1+A^2)-A);
    y = A*(R-Bvar)/(1+G);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="morse" style="margin-left: 20px;">morse</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = morse(rm,eps_well,k,r)
<span class="comment">%MORSE    Outputs MORSE potential data.</span>
<span class="comment">%   Y=MORSE(RM,EPS_WELL,K,R) generates a float array containing</span>
<span class="comment">%   a potential energy value for each r value using the Morse potential.</span>
<span class="comment">%   Units of potential energy are eV.</span>
<span class="comment">%</span>
<span class="comment">%   -- RM must be the float distance at which the potential is at a minimum.</span>
<span class="comment">%   -- EPS_WELL must be the float Morse well depth.</span>
<span class="comment">%   -- K must be the force constant at the well minimum in units of eV/Angstrom^2.</span>
<span class="comment">%   -- R must be the numerical array containing r values in units of</span>
<span class="comment">%   Angstrom.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_CALCPOTENTIAL</span>
    a  = sqrt(k/(2*eps_well));
    y = eps_well*(exp(-2*a.*(r-rm))-2*exp(-a.*(r-rm)));
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="numdiffusioncoef" style="margin-left: 20px;">numdiffusioncoef</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = numdiffusioncoef(Tvals,m1,m2,csdatafile)
<span class="comment">%NUMDIFFUSIONCOEF   Outputs float array with diffusion coefficient values.</span>
<span class="comment">%   Y=NUMDIFFUSIONCOEF(TVALS,M1,M2,P,CSDATAFILE) generates a float array</span>
<span class="comment">%   containing self-diffusion coefficient value for each value of Tvals by]</span>
<span class="comment">%   using trapezoidal integration.</span>
<span class="comment">%</span>
<span class="comment">%   -- TVALS must be an array of temperatures in Kelvin.</span>
<span class="comment">%   -- M1 must be mass in amu.</span>
<span class="comment">%   -- M2 must be mass in amu.</span>
<span class="comment">%   -- CSDATAFILE must be location of diffusion cross section data file.</span>
<span class="comment">%</span>
<span class="comment">%   See also NUMDIFFUSIONCS RUN_TRANSPORTCS</span>
kb = 8.617333262E-5; <span class="comment">%eV/K</span>
mred = m1*m2/(m1+m2);
csdata = readmatrix(csdatafile);
Evals = csdata(:,1); <span class="comment">%eV</span>
csvals = csdata(:,2); <span class="comment">%A^2</span>
amu_to_kg = 1/(6.022e26);
ev_to_j = 1.60218e-19;
a_to_m = 1e-10;
atomic_to_si = (amu_to_kg^(-1/2))*(ev_to_j^(3/2))*(a_to_m^(-2));

y = atomic_to_si*(3/8)*((2*pi/mred)^(0.5))*((kb*Tvals).^(3/2)).*(1./(reddifquad(Tvals,Evals,csvals))); <span class="comment">%PD in units of Pa * m^2 / s</span>
<span class="keyword">end</span>

<span class="keyword">function</span> y = reddifquad(Tvals,Evals,csvals)
kb = 8.617333262E-5; <span class="comment">%eV/K</span>
y = zeros(size(Tvals));
ct = 1;
<span class="keyword">for</span> T = Tvals
    reddifintegrand = ((kb*T).^(-3)).*exp(-Evals/(kb*T)).*(Evals.^2).*csvals;
    y(ct) = trapz(Evals,reddifintegrand);
    fprintf(<span class="string">'T = %f, omega = %f'</span>,T,y(ct)*0.5)
    ct = ct + 1;
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="numdiffusioncs" style="margin-left: 20px;">numdiffusioncs</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = numdiffusioncs(bvals,th)
<span class="comment">%NUMDIFFUSIONCS    Outputs diffusion cross-section value.</span>
<span class="comment">%   Y=NUMDIFFUSIONCS(SCATTERDATAFILE) generates diffusion cross-section</span>
<span class="comment">%   value by integrating scattering angle vs impact param data for a</span>
<span class="comment">%   specific energy using TRAPZ.</span>
<span class="comment">%</span>
<span class="comment">%   -- SCATTERDATAFILE must be the filepath to the scattering angle vs</span>
<span class="comment">%   impact para data.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_TRANSPORTCS</span>
difcsintegrand = 2*pi*(1-cos(th)).*bvals;
y = trapz(bvals,difcsintegrand);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="numstoppingcs" style="margin-left: 20px;">numstoppingcs</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = numstoppingcs(E,m1,m2,diffusioncs)
<span class="comment">%NUMSTOPPINGCS    Outputs stopping cross-section value.</span>
<span class="comment">%   Y=NUMSTOPPINGCS(SCATTERDATAFILE) generates a stopping cross-section</span>
<span class="comment">%   value using diffusion cs value, masses, and energy.</span>
<span class="comment">%</span>
<span class="comment">%   -- E must be energy in eV.</span>
<span class="comment">%   -- M1 must be the mass of species 1 in amu.</span>
<span class="comment">%   -- M2 must be the mass of species 2 in amu.</span>
<span class="comment">%   -- DIFFUSIONCS must be diffusion CS value for energy E.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_TRANSPORTCS</span>
yCM = 2*(m1*m2/(m1+m2)^2)*E*diffusioncs;
CMtoLab = (m1+m2)/m2;
y = yCM*CMtoLab;
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="numtotalcs" style="margin-left: 20px;">numtotalcs</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = numtotalcs(th_max,bvals,th)
<span class="comment">%NUMTOTALCS    Outputs total cross-section value.</span>
<span class="comment">%   Y=NUMTOTALCS(SCATTERDATAFILE) generates a total cross-section value</span>
<span class="comment">%   for a specific energy by finding the intersection of TH_MAX and the</span>
<span class="comment">%   scattering angle vs impact parameter curve.</span>
<span class="comment">%</span>
<span class="comment">%   -- TH_MAX must be the angle in radians used to determine total CS.</span>
<span class="comment">%   -- SCATTERDATAFILE must be the filepath to the scattering angle vs</span>
<span class="comment">%   impact para data.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_TRANSPORTCS</span>

bfine = min(bvals):0.00001:max(bvals);
th_p = th - th_max;
vqth = interp1(bvals,th_p,bfine);
bmax = max(data_zeros(bfine,vqth));
y = pi*bmax^2;
<span class="keyword">end</span>

<span class="keyword">function</span> x0 = data_zeros(x, y)
    <span class="comment">% Identify indices where there is a sign change between consecutive elements</span>
    zero_crossings = find((y(1:end-1) .* y(2:end)) &lt;= 0);

    <span class="comment">% Preallocate for the zero-crossing points</span>
    x0 = NaN(length(zero_crossings), 1);

    <span class="comment">% Loop through each detected zero-crossing for interpolation</span>
    <span class="keyword">for</span> k = 1:length(zero_crossings)
        <span class="comment">% Indices for interpolation points</span>
        idx1 = zero_crossings(k);
        idx2 = idx1 + 1;

        <span class="comment">% Linear interpolation between the points around zero-crossing</span>
        b = [1, x(idx1); 1, x(idx2)] \ [y(idx1); y(idx2)];
        x0(k) = -b(1) / b(2); <span class="comment">% Solving for x at y = 0</span>
    <span class="keyword">end</span>
    x0 = x0(~isnan(x0));
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="numtotalcscheb" style="margin-left: 20px;">numtotalcscheb</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = numtotalcscheb(th_max,bvals,th)
<span class="comment">%NUMTOTALCSCHEB    Outputs total cross-section value.</span>
<span class="comment">%   Y=NUMTOTALCSCHEB(SCATTERDATAFILE) generates a total cross-section value</span>
<span class="comment">%   for a specific energy by finding the intersection of TH_MAX and the</span>
<span class="comment">%   scattering angle vs impact parameter curve using Chebfun rootfinding.</span>
<span class="comment">%</span>
<span class="comment">%   -- TH_MAX must be the angle in radians used to determine total CS.</span>
<span class="comment">%   -- SCATTERDATAFILE must be the filepath to the scattering angle vs</span>
<span class="comment">%   impact para data.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_TRANSPORTCS</span>
th_p = th - th_max;
p = spline(bvals,th_p);
poly = @(r) ppval(p,r);
chebtotalcs = chebfun(poly,[min(bvals),max(bvals)]);
bmax = max(roots(chebtotalcs));
y = pi*bmax^2;
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="numvisccoef" style="margin-left: 20px;">numvisccoef</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = numvisccoef(Tvals,m1,m2,csdatafile)
<span class="comment">%NUMVISCCOEF   Outputs float array with viscosity coefficient values.</span>
<span class="comment">%   Y=NUMVISCCOEF(TVALS,M1,M2,CSDATAFILE) generates a float array</span>
<span class="comment">%   containing viscosity coefficient value for each value of Tvals by using</span>
<span class="comment">%   trapezoidal integration.</span>
<span class="comment">%</span>
<span class="comment">%   -- TVALS must be an array of temperatures in Kelvin.</span>
<span class="comment">%   -- M1 must be mass in amu.</span>
<span class="comment">%   -- M2 must be mass in amu.</span>
<span class="comment">%   -- CSDATAFILE must be location of viscosity cross section data file.</span>
<span class="comment">%</span>
<span class="comment">%   See also NUMDIFFUSIONCOEF RUN_TRANSPORTCS</span>
kb = 8.617333262E-5; <span class="comment">%eV/K</span>
mred = m1*m2/(m1+m2);
csdata = readmatrix(csdatafile);
Evals = csdata(:,1); <span class="comment">%eV</span>
csvals = csdata(:,2); <span class="comment">%A^2</span>
<span class="comment">% note that the 0.001629989 below is a unit conversion factor that converts</span>
<span class="comment">% [amu^0.5 * Angstrom^-2 * eV^0.5] --&gt; [kg^0.5 * m^-2 * Joules^0.5]</span>
y = (1E6)*0.001629989*(5/4)*((2*pi*mred)^(0.5))*((kb*Tvals).^(1/2)).*(1./(redviscquad(Tvals,Evals,csvals))); <span class="comment">%microPa s</span>
<span class="keyword">end</span>

<span class="keyword">function</span> y = redviscquad(Tvals,Evals,csvals)
kb = 8.617333262E-5; <span class="comment">%eV/K</span>
y = zeros(size(Tvals));
ct = 1;
<span class="keyword">for</span> T = Tvals
    redviscintegrand = ((kb*T).^(-4)).*exp(-Evals/(kb*T)).*(Evals.^3).*csvals;
    y(ct) = trapz(Evals,redviscintegrand);
    ct = ct + 1;
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="numvisccs" style="margin-left: 20px;">numvisccs</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = numvisccs(bvals,th)
<span class="comment">%NUMVISCCS    Outputs viscosity cross-section value.</span>
<span class="comment">%   Y=NUMVISCCS(SCATTERDATAFILE) generates a viscosity cross-section</span>
<span class="comment">%   value by integrating scattering angle vs impact param data for a</span>
<span class="comment">%   specific energy using TRAPZ.</span>
<span class="comment">%</span>
<span class="comment">%   -- SCATTERDATAFILE must be the filepath to the scattering angle vs</span>
<span class="comment">%   impact para data.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_TRANSPORTCS</span>
difcsintegrand = 2*pi*(1-cos(th).^2).*bvals;
y = trapz(bvals,difcsintegrand);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="powerlaw" style="margin-left: 20px;">powerlaw</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = powerlaw(a,k,r)
<span class="comment">%POWERLAW    Outputs power law potential data.</span>
<span class="comment">%   Y=POWERLAW(A,K,R) generates a float array containing a potential</span>
<span class="comment">%   energy value for each r value using the basic power law potential.</span>
<span class="comment">%   Units of potential energy are eV.</span>
<span class="comment">%</span>
<span class="comment">%   -- A is the first power law coefficient.</span>
<span class="comment">%   -- K is the exponent power law coefficient.</span>
<span class="comment">%   -- R must be the numerical array containing r values in units of</span>
<span class="comment">%   Angstrom.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_CALCPOTENTIAL</span>
    y = a*r.^(-k);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="run_calcpotential" style="margin-left: 20px;">run_calcpotential</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = run_calcpotential(filepath,datafilepath)
<span class="comment">%RUN_CALCPOTENTIAL    Reads input file and generates potential data.</span>
<span class="comment">%   RUN_CALCPOTENTIAL(FILEPATH,DATAFILEPATH) reads the user-specified input</span>
<span class="comment">%   file, generates potential data using the appropriate potential</span>
<span class="comment">%   function, and saves the data to a user-specified folder.</span>
<span class="comment">%</span>
<span class="comment">%   -- FILEPATH must specify the path to where input file is.</span>
<span class="comment">%   -- DATAFILEPATH must specify where to save the potential data.</span>
<span class="comment">%</span>
<span class="comment">%   See also COULOMB LJ_126 LJ_124 ZBL POWERLAW MORSE</span>
    run(filepath);
    r = minR:Rstep:maxR;
    <span class="keyword">if</span> strcmp(Potential_Type,<span class="string">"Coulomb"</span>)
        data = coulomb(Z1,Z2,r);
        datapath  = fullfile(datafilepath,<span class="string">'/coulombdata.csv'</span>);
        A = [r' data'];
        writematrix(A,datapath);
        y = datapath;
    <span class="keyword">elseif</span> strcmp(Potential_Type,<span class="string">"12-6 Lennard-Jones"</span>)
        data = lj_126(eps_well,sig,r);
        datapath  = fullfile(datafilepath,<span class="string">'/126ljdata.csv'</span>);
        A = [r' data'];
        writematrix(A,datapath);
        y = datapath;
    <span class="keyword">elseif</span> strcmp(Potential_Type,<span class="string">"12-4 Lennard-Jones"</span>)
        data = lj_124(eps_well,sig,r);
        datapath  = fullfile(datafilepath,<span class="string">'/124ljdata.csv'</span>);
        A = [r' data'];
        writematrix(A,datapath);
        y = datapath;
    <span class="keyword">elseif</span> strcmp(Potential_Type,<span class="string">"ZBL"</span>)
        data = zbl(Z1,Z2,r);
        datapath  = fullfile(datafilepath,<span class="string">'/zbldata.csv'</span>);
        A = [r' data'];
        writematrix(A,datapath);
        y = datapath;
    <span class="keyword">elseif</span> strcmp(Potential_Type,<span class="string">"Morse"</span>)
        data = morse(rm,eps_well,k,r);
        datapath  = fullfile(datafilepath,<span class="string">'/morsedata.csv'</span>);
        A = [r' data'];
        writematrix(A,datapath);
        y = datapath;
    <span class="keyword">elseif</span> strcmp(Potential_Type,<span class="string">"Power Law"</span>)
        data = powerlaw(a,k,r);
        datapath = fullfile(datafilepath,<span class="string">'/powerlawdata.csv'</span>);
        A = [r' data'];
        writematrix(A,datapath);
        y = datapath;
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="run_dsmccoef" style="margin-left: 20px;">run_dsmccoef</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = run_dsmccoef(inputfile,datapath)
<span class="comment">%RUN_DSMCCOEF    Reads dsmc coef input file and calculates dsmc params.</span>
<span class="comment">%   RUN_DSMCCOEF(INPUTFILE,DATAPATH) reads the user-specified parameters</span>
<span class="comment">%   from the input file and calculates DSMC params for the VSS and VHS</span>
<span class="comment">%   models.</span>
<span class="comment">%</span>
<span class="comment">%   -- INPUTFILE must specify the path to where input file is.</span>
<span class="comment">%   -- DATAFILEPATH must specify where to save the param table.</span>
<span class="comment">%</span>
<span class="comment">%   See also VHSCOEF VHSVISCOSITY VSSCOEF VSSDIFFUSION</span>
y = datapath;
run(inputfile);
mr = m1*m2/(m1+m2);
mrkg = mr/(6.022E26);
kb = 1.380649E-23; <span class="comment">%J/K</span>
cd(sprintf(<span class="string">'%s'</span>,y))
mkdir <span class="string">dsmcfitdata</span>
visccoefdata = readmatrix(viscdatafile);
visccoef = visccoefdata(:,2);
Tvals = visccoefdata(:,1);
Tfine = min(Tvals):0.01:max(Tvals);
vqvisc = interp1(Tvals,visccoef,Tfine);
delta = (max(Tvals) - min(Tvals))/N;
offset = min(Tvals);
dsmcdatapath = fullfile(datapath,<span class="string">'/dsmccoeftable.csv'</span>);
A = [];
C = [Tfine' vqvisc'];
interpviscdata = fullfile(datapath,<span class="string">'/dsmcfitdata/dsmcfitviscdata.csv'</span>);
writematrix(C,interpviscdata);
<span class="keyword">for</span> i = 1:N
    minT = offset;
    maxT = minT + delta;
    excludeT = ((Tfine &lt; minT) | (Tfine &gt; maxT));
    fitT = Tfine;
    fitT(excludeT) = [];
    T_sample = 0.5*(minT + maxT);
    vhscoefs = my_VHScoef(fitT,T_sample,excludeT,vqvisc,tol);
    mu_sample = vhscoefs(1);
    omega = vhscoefs(2);
    dcollision = (1E10)*sqrt(15*sqrt(mrkg*kb*T_sample/pi)/<span class="keyword">...</span>
        (2*(5-2*omega)*(7-2*omega)*(mu_sample/(1E6)))); <span class="comment">%Angstrom</span>
    viscfit = my_VHSviscosity(fitT,omega,T_sample,mu_sample);
    viscfitdatapath = fullfile(datapath,sprintf(<span class="string">'/dsmcfitdata/viscfitdata_n=%i.csv'</span>,i));
    B1 = [fitT' viscfit'];
    writematrix(B1,viscfitdatapath);
    A = [A; minT maxT mu_sample T_sample omega dcollision];
    offset  = offset + delta;
<span class="keyword">end</span>
A = array2table(A,<span class="string">'VariableNames'</span>,{<span class="string">'Tmin'</span>,<span class="string">'Tmax'</span>,<span class="string">'mu_ref'</span>,<span class="string">'T_ref'</span>,<span class="string">'omega'</span>,<span class="string">'collision_diam'</span>});
disp(A)
writetable(A,dsmcdatapath);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="run_fitpotential" style="margin-left: 20px;">run_fitpotential</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = run_fitpotential(filepath,datapath)
<span class="comment">%RUN_FITPOTENTIAL    Reads fitting input file and generates cfit object.</span>
<span class="comment">%   RUN_FITPOTENTIAL(FILEPATH,DATAFILEPATH) reads the user-specified</span>
<span class="comment">%   fitting parameters from the fitting input file, creates a fittype based</span>
<span class="comment">%   off those parameters using the appropriate character function or</span>
<span class="comment">%   string, and then creates a fit object using the FIT function.</span>
<span class="comment">%</span>
<span class="comment">%   -- FILEPATH must specify the path to where input file is.</span>
<span class="comment">%   -- DATAFILEPATH must specify where the potential data is saved.</span>
<span class="comment">%</span>
<span class="comment">%   See also COULOMBCHAR ZBLCHAR</span>
    run(filepath);
    <span class="keyword">if</span> strcmp(Potential_Type,<span class="string">"Coulomb"</span>)
        ft = fittype(coulombchar(Z1),dependent=<span class="string">"y"</span>,independent=<span class="string">"x"</span>,<span class="keyword">...</span>
        coefficients=<span class="string">"z2"</span>);
        t = readmatrix(datapath);
        excludex = ((t(:,1) &lt; minR) | (t(:,1) &gt; maxR));
        xvals = t(:,1);
        yvals = t(:,2);
        xvals(excludex) = [];
        yvals(excludex) = [];
        y = fit(xvals,yvals,ft,<span class="string">'Exclude'</span>,(xvals&lt;minR)&amp;(xvals&gt;maxR),<span class="keyword">...</span>
            <span class="string">'TolFun'</span>,tol,<span class="string">'Lower'</span>,minZ2,<span class="string">'Upper'</span>,maxZ2);
    <span class="keyword">elseif</span> strcmp(Potential_Type,<span class="string">"ZBL"</span>)
        ft = fittype(zblchar(Z1),dependent=<span class="string">"y"</span>,independent=<span class="string">"x"</span>,<span class="keyword">...</span>
        coefficients=<span class="string">"z2"</span>);
        t = readmatrix(datapath);
        excludex = ((t(:,1) &lt; minR) | (t(:,1) &gt; maxR));
        xvals = t(:,1);
        yvals = t(:,2);
        xvals(excludex) = [];
        yvals(excludex) = [];
        y = fit(xvals,yvals,ft,<span class="string">'Exclude'</span>,(xvals&lt;minR)&amp;(xvals&gt;maxR),<span class="keyword">...</span>
            <span class="string">'TolFun'</span>,tol,<span class="string">'Lower'</span>,minZ2,<span class="string">'Upper'</span>,maxZ2);
    <span class="keyword">elseif</span> strcmp(Potential_Type,<span class="string">"12-6 Lennard-Jones"</span>)
        t = readmatrix(datapath);
        excludex = ((t(:,1) &lt; minR) | (t(:,1) &gt; maxR));
        xvals = t(:,1);
        yvals = t(:,2);
        xvals(excludex) = [];
        yvals(excludex) = [];
        ft = fittype(<span class="string">"4*eps_well*(((sigma./x).^12)-((sigma./x).^6))"</span>,dependent=<span class="string">"y"</span>,<span class="keyword">...</span>
                    independent=<span class="string">"x"</span>,coefficients=[<span class="string">"eps_well"</span> <span class="string">"sigma"</span>]);
        y = fit(xvals,yvals,ft,<span class="keyword">...</span>
                    <span class="string">'TolFun'</span>,tol,<span class="string">'Lower'</span>,[min_eps min_sigma],<span class="keyword">...</span>
                    <span class="string">'Upper'</span>,[max_eps max_sigma],<span class="string">'StartPoint'</span>,[eps_start sigma_start]);
    <span class="keyword">elseif</span> strcmp(Potential_Type,<span class="string">"12-4 Lennard-Jones"</span>)
        t = readmatrix(datapath);
        excludex = ((t(:,1) &lt; minR) | (t(:,1) &gt; maxR));
        xvals = t(:,1);
        yvals = t(:,2);
        xvals(excludex) = [];
        yvals(excludex) = [];
        ft = fittype(<span class="string">"0.5*(3^1.5)*eps_well*(((sigma./x).^12)-((sigma./x).^4))"</span>,dependent=<span class="string">"y"</span>,<span class="keyword">...</span>
                    independent=<span class="string">"x"</span>,coefficients=[<span class="string">"eps_well"</span> <span class="string">"sigma"</span>]);
        y = fit(xvals,yvals,ft,<span class="keyword">...</span>
                    <span class="string">'TolFun'</span>,tol,<span class="string">'Lower'</span>,[min_eps min_sigma],<span class="keyword">...</span>
                    <span class="string">'Upper'</span>,[max_eps max_sigma],<span class="string">'StartPoint'</span>,[eps_start sigma_start]);
    <span class="keyword">elseif</span> strcmp(Potential_Type,<span class="string">"Morse"</span>)
        t = readmatrix(datapath);
        excludex = ((t(:,1) &lt; minR) | (t(:,1) &gt; maxR));
        xvals = t(:,1);
        yvals = t(:,2);
        xvals(excludex) = [];
        yvals(excludex) = [];
        ft = fittype(<span class="string">"eps_well*(exp(-2*sqrt(k/(2*eps_well)).*(x-rm))-2*exp(-sqrt(k/(2*eps_well)).*(x-rm)))"</span>, <span class="keyword">...</span>
            dependent=<span class="string">"y"</span>,independent=<span class="string">"x"</span>,coefficients=[<span class="string">"rm"</span> <span class="string">"eps_well"</span> <span class="string">"k"</span>]);
        y = fit(xvals,yvals,ft,<span class="keyword">...</span>
                    <span class="string">'TolFun'</span>,tol,<span class="string">'Lower'</span>,[min_rm min_eps min_k],<span class="keyword">...</span>
                    <span class="string">'Upper'</span>,[max_rm max_eps max_k],<span class="string">'StartPoint'</span>,[rm_start eps_start k_start]);
    <span class="keyword">elseif</span> strcmp(Potential_Type,<span class="string">"Power Law"</span>)
        t = readmatrix(datapath);
        excludex = ((t(:,1) &lt; minR) | (t(:,1) &gt; maxR));
        xvals = t(:,1);
        yvals = t(:,2);
        xvals(excludex) = [];
        yvals(excludex) = [];
        ft = fittype(<span class="string">"a*x.^(-k)"</span>,dependent=<span class="string">"y"</span>,<span class="keyword">...</span>
                    independent=<span class="string">"x"</span>,coefficients=[<span class="string">"a"</span> <span class="string">"k"</span>]);
        y = fit(xvals,yvals,ft,<span class="keyword">...</span>
                    <span class="string">'TolFun'</span>,tol,<span class="string">'Lower'</span>,[min_a min_k],<span class="keyword">...</span>
                    <span class="string">'Upper'</span>,[max_a max_k],<span class="string">'StartPoint'</span>,[a_start k_start]);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="run_scatteringintegrals" style="margin-left: 20px;">run_scatteringintegrals</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = run_scatteringintegrals(filepath,datafilepath,progressBar)
<span class="comment">%RUN_SCATTERINGINTEGRALS    Reads scattering input file and calculates scattering integrals.</span>
<span class="comment">%   RUN_SCATTERINGINTEGRALS(FILEPATH,DATAFILEPATH) reads the user-specified</span>
<span class="comment">%   scattering parameters from the scattering input file and calculates the</span>
<span class="comment">%   differential scattering cross section, impact parameter, and distance</span>
<span class="comment">%   of closest approach (for the Coulomb case), or calculates the</span>
<span class="comment">%   scattering angle and distance of closest approach (general) case.</span>
<span class="comment">%</span>
<span class="comment">%   -- FILEPATH must specify the path to where input file is.</span>
<span class="comment">%   -- DATAFILEPATH must specify where to save the scattering integral data.</span>
<span class="comment">%</span>
<span class="comment">%   See also IMPACT DIFSCATTER DISTCLOSE DOCAROOT GMQUADSCATTERINGANGLE</span>
    y = datafilepath;
    run(filepath);
    <span class="keyword">if</span> logspace_on == 1
        minElog = log10(minE);
        maxElog = log10(maxE);
        Evals = logspace(minElog,maxElog,logstep);
    <span class="keyword">elseif</span> logspace_on == 0
        Evals = minE:Estep:maxE;
    <span class="keyword">end</span>
    cd(sprintf(<span class="string">'%s'</span>,y))

    <span class="keyword">if</span> strcmp(inttype,<span class="string">'Exact Coulomb'</span>)
        theta = theta_min:theta_step:theta_max;
        numESteps = numel(Evals);
        numthSteps = numel(theta);
        A = zeros(numthSteps,numESteps);
        B = zeros(numthSteps,numESteps);
        C = zeros(numthSteps,2*numESteps);
        colNames = strings(1,1+numESteps);
        A(:,1) = theta';
        B(:,1) = theta';
        colNames(1,1) = <span class="string">'theta'</span>;
        colNamesC = strings(1,2*numESteps);
        <span class="keyword">for</span> i = 1:numESteps
            E = Evals(i);
            <span class="keyword">if</span> nargin &gt; 2 &amp;&amp; isvalid(progressBar)
                progressBar.Value = i / numESteps;
                progressBar.Message = sprintf(<span class="string">'Running %f eV...'</span>, E);
            <span class="keyword">end</span>
            mydifscatter = difscatter(Z1, Z2, theta, E);
            impactparam = impact(Z2, Z2, theta, E);
            doca = distclose(Z1, Z2, impactparam, E);
            colNames(i+1) = sprintf(<span class="string">'E=%f'</span>,E);
            colNamesC(1,2*i-1) = sprintf(<span class="string">'bval E=%f'</span>,E);
            colNamesC(1,2*i) = sprintf(<span class="string">'doca E=%f'</span>,E);
            A(:,i+1) = mydifscatter';
            B(:,i+1) = impactparam';
            C(:,2*i-1) = impactparam';
            C(:,2*i) = doca';
        <span class="keyword">end</span>
        ATable = array2table(A,<span class="string">'VariableNames'</span>,colNames);
        BTable = array2table(B,<span class="string">'VariableNames'</span>,colNames);
        CTable = array2table(C,<span class="string">'VariableNames'</span>,colNamesC);
        difscatterdatapath = fullfile(datafilepath,<span class="string">'/difscatterdata.csv'</span>);
        impactparamdatapath = fullfile(datafilepath,<span class="string">'/impactparamdata.csv'</span>);
        docadatapath = fullfile(datafilepath,<span class="string">'/docadata.csv'</span>);
        writetable(ATable, difscatterdatapath);
        writetable(BTable, impactparamdatapath);
        writetable(CTable, docadatapath);

    <span class="keyword">elseif</span> strcmp(inttype, <span class="string">'Numerical'</span>)
        run(fitfile);
        <span class="keyword">if</span> strcmp(Potential_Type, <span class="string">'Coulomb'</span>)
            potential = @(r) coulomb(Z1, z2_param, r);
        <span class="keyword">elseif</span> strcmp(Potential_Type, <span class="string">'12-6 Lennard-Jones'</span>)
            potential = @(r) lj_126(eps_param, sigma_param, r);
        <span class="keyword">elseif</span> strcmp(Potential_Type, <span class="string">'12-4 Lennard-Jones'</span>)
            potential = @(r) lj_124(eps_param, sigma_param, r);
        <span class="keyword">elseif</span> strcmp(Potential_Type, <span class="string">'ZBL'</span>)
            potential = @(r) zbl(Z1, z2_param, r);
        <span class="keyword">elseif</span> strcmp(Potential_Type, <span class="string">'Morse'</span>)
            potential = @(r) morse(rm_param,eps_param,k_param,r);
        <span class="keyword">elseif</span> strcmp(Potential_Type, <span class="string">'Power Law'</span>)
            potential = @(r) powerlaw(a_param, k_param, r);
        <span class="keyword">end</span>
        <span class="keyword">if</span> blogspace_on == 1
            minblog = log10(bmin);
            maxblog = log10(bmax);
            bvals = logspace(minblog,maxblog,blogstep);
        <span class="keyword">elseif</span> blogspace_on == 0
            bvals = bmin:bstep:bmax;
        <span class="keyword">end</span>

        numESteps = numel(Evals);
        numBSteps = numel(bvals);
        A = zeros(numBSteps,numESteps);
        B = zeros(numBSteps,numESteps);
        colNames = strings(1,1+numESteps);
        A(:,1) = bvals';
        B(:,1) = bvals';
        colNames(1,1) = <span class="string">'bvals'</span>;

        <span class="keyword">for</span> i = 1:numESteps
            E = Evals(i);
            <span class="keyword">if</span> nargin &gt; 2 &amp;&amp; isvalid(progressBar)
                progressBar.Value = i / numESteps;
                progressBar.Message = sprintf(<span class="string">'Running %f eV...'</span>, E);
            <span class="keyword">end</span>
            docas = zeros(1, length(bvals));
            th = zeros(1, length(bvals));
            thmagic = zeros(1,length(bvals));
            <span class="keyword">for</span> j = 1:length(bvals)
                docas(j) = DOCAroot(E, bvals(j), potential, minroot, maxroot,chebfunpath);
                th(j) = GMquadScatteringAngle(potential, E, bvals(j), docas(j), 20);
                <span class="keyword">if</span> strcmp(Potential_Type, <span class="string">'ZBL'</span>)
                    thmagic(j) = magicscatter(E,bvals(j),potential,docas(j),Z1,z2_param);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            colNames(i+1) = sprintf(<span class="string">'E=%f'</span>,E);
            A(:,i+1) = th';
            B(:,i+1) = docas';
            C = [bvals' thmagic'];
            <span class="comment">%magicscatterpath = fullfile(datafilepath,sprintf('/magicscatterdata/scatterangledata_%f.csv',E));</span>
            <span class="comment">%writematrix(C, magicscatterpath)</span>
        <span class="keyword">end</span>
        ATable = array2table(A,<span class="string">'VariableNames'</span>,colNames);
        BTable = array2table(B,<span class="string">'VariableNames'</span>,colNames);
        scatterangdatapath = fullfile(datafilepath,<span class="string">'/scatterangledata.csv'</span>);
        docadatapath = fullfile(datafilepath,<span class="string">'/docadata.csv'</span>);
        writetable(ATable, scatterangdatapath);
        writetable(BTable, docadatapath);
        <span class="comment">%writematrix(C, magicscatterpath)</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="run_transportCS" style="margin-left: 20px;">run_transportCS</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> run_transportCS(filepath,datafilepath)
<span class="comment">%RUN_TRANSPORTCS    Reads cross-section input file and calculates transport cross-sections.</span>
<span class="comment">%   RUN_TRANSPORTCS(FILEPATH,DATAFILEPATH) reads the user-specified</span>
<span class="comment">%   cross-section (CS) parameters from the cross-section input file and</span>
<span class="comment">%   calculates the diffusion CS and viscosity CS (for the exact LJ case in</span>
<span class="comment">%   "Khrapak, S.A. Accurate transport cross sections for the Lennard-Jones</span>
<span class="comment">%   potential. Eur. Phys. J. D 68, 276 (2014)") or the diffusion CS,</span>
<span class="comment">%   viscosity CS, stopping CS, and total CS (for the general case).</span>
<span class="comment">%</span>
<span class="comment">%   -- FILEPATH must specify the path to where input file is.</span>
<span class="comment">%   -- DATAFILEPATH must specify where to save the CS data.</span>
<span class="comment">%</span>
<span class="comment">%   See also DIFFUSIONCS VISCOSITYCS NUMDIFFUSIONCS NUMVISCCS</span>
<span class="comment">%   NUMTOTALCS NUMSTOPPINGCS</span>
    run(filepath);
    <span class="keyword">if</span> logspace_on == 1
        minElog = log10(minE);
        maxElog = log10(maxE);
        Evals = logspace(minElog,maxElog,logstep);
    <span class="keyword">elseif</span> logspace_on == 0
        Evals = minE:Estep:maxE;
    <span class="keyword">end</span>
    <span class="keyword">if</span> strcmp(inttype,<span class="string">'Exact LJ'</span>)
        beta = welldepth./(2*Evals);
        difcs = diffusioncs(beta);
        visccs = viscositycs(beta);
        A = [Evals' difcs'];
        B = [Evals' visccs'];

    <span class="keyword">elseif</span> strcmp(inttype,<span class="string">'Numerical'</span>)
        difcs = zeros(1,length(Evals));
        visccs = zeros(1,length(Evals));
        stoppingcs = zeros(1,length(Evals));
        totalcs = zeros(1,length(Evals));
        <span class="keyword">for</span> j = 1:length(Evals)
            disp(Evals(j))
            file = datafile;
            scatterdata = readmatrix(file);
            th = scatterdata(:,j+1);
            bvals = scatterdata(:,1);
            <span class="keyword">if</span> strcmp(thetacutoff,<span class="string">'Quantum'</span>)
                docadata = readmatrix(docafile);
                doca = docadata(:,j+1)*(1e-10); <span class="comment">%m</span>
                hbar = 1.054571817E-34; <span class="comment">%J*s</span>
                m_redamu  = m1*m2/(m1+m2);
                m_red = m_redamu/(6.022E26); <span class="comment">%kg</span>
                E = Evals(j)*(1.60218E-19); <span class="comment">%J</span>
                v_cm = sqrt(2*E/m_red);
                lam_bar = hbar/(m_red*v_cm);
                th_c = lam_bar./doca;
            <span class="keyword">elseif</span> strcmp(thetacutoff,<span class="string">'Manual'</span>)
                th_c = th_max;
            <span class="keyword">end</span>
            difcs(j) = numdiffusioncs(bvals,th);
            visccs(j) = numvisccs(bvals,th);
            stoppingcs(j) = numstoppingcs(Evals(j),m1,m2,diffusioncs(j));
            totalcs(j) = numtotalcs(th_c,bvals,th);
        <span class="keyword">end</span>
        CMtoLab = (m1+m2)/m2;
        A = [Evals' difcs'];
        B = [Evals' visccs'];
        C = [(CMtoLab*Evals)' stoppingcs'];
        D = [Evals' totalcs'];
        stoppingcsdatapath = fullfile(datafilepath,<span class="string">'/stoppingcsdata.csv'</span>);
        totalcsdatapath = fullfile(datafilepath,<span class="string">'/totalcsdata.csv'</span>);
        writematrix(C,stoppingcsdatapath);
        writematrix(D,totalcsdatapath);
    <span class="keyword">end</span>
    diffusioncsdatapath  = fullfile(datafilepath,<span class="string">'/diffusioncsdata.csv'</span>);
    viscositycsdatapath = fullfile(datafilepath,<span class="string">'/viscositycsdata.csv'</span>);
    writematrix(A, diffusioncsdatapath);
    writematrix(B,viscositycsdatapath);

<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="run_transportcoefs" style="margin-left: 20px;">run_transportcoefs</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = run_transportcoefs(filepath,datafilepath)
<span class="comment">%RUN_TRANSPORTCOEFS    Reads transport input file and calculates transport coefs.</span>
<span class="comment">%   RUN_TRANSPORTCOEFS(FILEPATH,DATAFILEPATH) reads the user-specified</span>
<span class="comment">%   transport parameters from the transport input file and calculates the</span>
<span class="comment">%   self-diffusion or viscosity coefficient.</span>
<span class="comment">%</span>
<span class="comment">%   -- FILEPATH must specify the path to where input file is.</span>
<span class="comment">%   -- DATAFILEPATH must specify where to save the coef data.</span>
<span class="comment">%</span>
<span class="comment">%   See also DIFFUSIONCOEF VISCCOEF NUMDIFFUSIONCOEF NUMVISCCOEF</span>
    <span class="comment">%disp(filepath)</span>
    run(filepath);
    Tvals = minT:Tstep:maxT;
    <span class="keyword">if</span> strcmp(inttype,<span class="string">'Exact LJ'</span>) | strcmp(inttype,<span class="string">'Trapezoidal LJ'</span>)
            difcoef = diffusion_coef(welldepth,Tvals,m1,m2,d,inttype,diffusiondatafile);
            diffusioncoefdatapath  = fullfile(datafilepath,<span class="string">'/diffusioncoefdata.csv'</span>);
            A = [Tvals' difcoef'];
            writematrix(A, diffusioncoefdatapath);
            viscositycoef = visc_coef(welldepth,Tvals,m1,m2,d,inttype,viscositydatafile);
            visccoefdatapath  = fullfile(datafilepath,<span class="string">'/viscositycoefdata.csv'</span>);
            B = [Tvals' viscositycoef'];
            writematrix(B, visccoefdatapath);
            y = datafilepath;
    <span class="keyword">elseif</span> strcmp(inttype,<span class="string">'Numerical'</span>)
            diffusioncoef = numdiffusioncoef(Tvals,m1,m2,diffusiondatafile);
            diffusioncoefdatapath  = fullfile(datafilepath,<span class="string">'/diffusioncoefdata.csv'</span>);
            A = [Tvals' diffusioncoef'];
            writematrix(A, diffusioncoefdatapath);
            visccoef = numvisccoef(Tvals,m1,m2,viscositydatafile);
            visccoefdatapath  = fullfile(datafilepath,<span class="string">'/viscositycoefdata.csv'</span>);
            B = [Tvals' visccoef'];
            writematrix(B, visccoefdatapath);
            coefdatapath = datafilepath;
            y = coefdatapath;
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="run_vhscoef" style="margin-left: 20px;">run_vhscoef</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = run_vhscoef(inputfile,datapath)
<span class="comment">%RUN_VHSCOEF    Reads VHS coef input file and calculates VHS params.</span>
<span class="comment">%   RUN_DSMCCOEF(INPUTFILE,DATAPATH) reads the user-specified parameters</span>
<span class="comment">%   from the input file and calculates DSMC params for the VHS</span>
<span class="comment">%   model.</span>
<span class="comment">%</span>
<span class="comment">%   -- INPUTFILE must specify the path to where input file is.</span>
<span class="comment">%   -- DATAFILEPATH must specify where to save the param table.</span>
<span class="comment">%</span>
<span class="comment">%   See also VHSCOEF VHSVISCOSITY</span>
y = datapath;
run(inputfile);
<span class="comment">%mr = m1*m2/(m1+m2);</span>
mr = m1;
mrkg = mr/(6.022E26);
kb = 1.380649E-23; <span class="comment">%J/K</span>
cd(sprintf(<span class="string">'%s'</span>,y))
mkdir <span class="string">vhsfitdata</span>
visccoefdata = readmatrix(viscdatafile);
visccoef = visccoefdata(:,2);
Tvals = visccoefdata(:,1);
Tfine = min(Tvals):0.01:max(Tvals);
vqvisc = interp1(Tvals,visccoef,Tfine);
delta = (max(Tvals) - min(Tvals))/N;
offset = min(Tvals);
vhsdatapath = fullfile(datapath,<span class="string">'/vhscoeftable.csv'</span>);
A = [];
C = [Tfine' vqvisc'];
interpviscdata = fullfile(datapath,<span class="string">'/vhsfitdata/vhsfitviscdata.csv'</span>);
writematrix(C,interpviscdata);
<span class="keyword">for</span> i = 1:N
    minT = offset;
    maxT = minT + delta;
    excludeT = ((Tfine &lt; minT) | (Tfine &gt; maxT));
    fitT = Tfine;
    fitT(excludeT) = [];
    T_sample = 0.5*(minT + maxT);
    mu_sample = interp1(Tfine, vqvisc, T_sample);
    vhscoefs = VHScoef(fitT,T_sample,mu_sample,excludeT,vqvisc,tol);
    omega = vhscoefs(2);
    dcollision = (1E10)*sqrt(15*sqrt(mrkg*kb*T_sample/pi)/<span class="keyword">...</span>
        (2*(5-2*omega)*(7-2*omega)*(mu_sample/(1E6)))); <span class="comment">%Angstrom</span>
    viscfit = VHSviscosity(fitT,omega,T_sample,mu_sample);
    viscfitdatapath = fullfile(datapath,sprintf(<span class="string">'/vhsfitdata/viscfitdata_n=%i.csv'</span>,i));
    B1 = [fitT' viscfit'];
    writematrix(B1,viscfitdatapath);
    A = [A; minT maxT mu_sample T_sample omega dcollision];
    offset  = offset + delta;
<span class="keyword">end</span>
A = array2table(A,<span class="string">'VariableNames'</span>,{<span class="string">'Tmin'</span>,<span class="string">'Tmax'</span>,<span class="string">'mu_ref'</span>,<span class="string">'T_ref'</span>,<span class="string">'omega'</span>,<span class="string">'collision_diam'</span>});
disp(A)
writetable(A,vhsdatapath);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="run_vsscoef" style="margin-left: 20px;">run_vsscoef</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = run_vsscoef(inputfile,datapath)
<span class="comment">%RUN_VSSCOEF    Reads VSS coef input file and calculates VSS params.</span>
<span class="comment">%   RUN_DSMCCOEF(INPUTFILE,DATAPATH) reads the user-specified parameters</span>
<span class="comment">%   from the input file and calculates DSMC params for the VSS</span>
<span class="comment">%   model.</span>
<span class="comment">%</span>
<span class="comment">%   -- INPUTFILE must specify the path to where input file is.</span>
<span class="comment">%   -- DATAFILEPATH must specify where to save the param table.</span>
<span class="comment">%</span>
<span class="comment">%   See also VSSALPHA VSSDIAMETER VSSCONVERGENCE</span>
y = datapath;
run(inputfile);
<span class="comment">%mr = m1*m2/(m1+m2);</span>
mr = m1;
mrkg = mr/(6.022E26);
molarkg = mr/(1E3);
difcoefdata = readmatrix(diffusiondatafile);
vhscoefdata = readmatrix(vhstablefile);
viscvals = vhscoefdata(:,3)*(1E-6);
omegavals = vhscoefdata(:,5);
alphavals = alphaguess*ones(length(omegavals),1);
Tvals = vhscoefdata(:,4);
difcoef = difcoefdata(:,2);
difcoef_T = difcoefdata(:,1);
dif_sample = interp1(difcoef_T, difcoef, Tvals);
max_iter = 100;
iter = 0;
<span class="keyword">while</span> VSSconvergence(alphavals,omegavals,molarkg,Tvals,dif_sample,viscvals,tol) &amp;&amp; iter &lt; max_iter
diams = VSSdiameter(alphavals,omegavals,mrkg,Tvals,viscvals);
newalpha = VSSalpha(omegavals,mrkg,molarkg,Tvals,dif_sample,diams);
alphavals = newalpha;
iter = iter + 1;
<span class="keyword">end</span>
<span class="keyword">if</span> iter == max_iter
    warning(<span class="string">'Reached maximum number of iterations without convergence.'</span>);
<span class="keyword">end</span>
diams = VSSdiameter(alphavals,omegavals,mrkg,Tvals,viscvals);
diams_angstrom  = diams*(1E10);
A = [Tvals alphavals diams_angstrom];
vssdatapath = fullfile(datapath,<span class="string">'/VSScoeftable.csv'</span>);
A = array2table(A,<span class="string">'VariableNames'</span>,{<span class="string">'Reference Temp (K)'</span>, <span class="string">'alpha'</span>,<span class="string">'collision_diam'</span>});
disp(A)
writetable(A,vssdatapath);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="visc_coef" style="margin-left: 20px;">visc_coef</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = visc_coef(well_depth,T,m1,m2,d,inttype,data)
<span class="comment">%VISC_COEF    Outputs viscosity coefficient.</span>
<span class="comment">%   Y=VISC_COEF(WELL_DEPTH,T,M1,M2,D,INTTYPE,DATA) generates a float</span>
<span class="comment">%   array containing a viscosity coefficient value for each temperature</span>
<span class="comment">%   using a Lennard_Jones potential (from "Khrapak, S.A. Accurate transport</span>
<span class="comment">%   cross sections for the Lennard-Jones potential. Eur. Phys. J. D 68, 276</span>
<span class="comment">%   (2014)"). Units of viscosity coefficient are micro-Pascal*s.</span>
<span class="comment">%</span>
<span class="comment">%   -- WELL-DEPTH must be the LJ well-depth in Kelvin.</span>
<span class="comment">%   -- T must be a float array containing temperature values in units of K.</span>
<span class="comment">%   -- M1 must be the mass of species 1 in amu.</span>
<span class="comment">%   -- M2 must be the mass of species 2 in amu.</span>
<span class="comment">%   -- D must be the sigma LJ parameter in units of Angstrom.</span>
<span class="comment">%   -- INTTYPE must be a character string specifying if the integral will</span>
<span class="comment">%   be exact or numerical.</span>
<span class="comment">%   -- DATA must be a character string filepath that gives the location of</span>
<span class="comment">%   the cross section data.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_TRANSPORTCS</span>
Tjoul = T.*(1.380649e-23);
mu = (m1*m2)/(m1+m2);
mukg = mu*(1.66054e-27);
dm = d*(1e-10);
Tstar = T/well_depth;
<span class="keyword">if</span> strcmp(inttype,<span class="string">'Exact LJ'</span>)
y = (1e6)*(5*sqrt(2*pi)/8)*(((mukg)^(1/2))*(Tjoul).^(1/2))./(((dm)^2) <span class="keyword">...</span>
    *reducedviscint(Tstar));
<span class="keyword">elseif</span> strcmp(inttype,<span class="string">'Trapezoidal LJ'</span>)
y = (1e6)*(5*sqrt(2*pi)/8)*(((mukg)^(1/2))*(Tjoul).^(1/2))./(((dm)^2) <span class="keyword">...</span>
    *reducedviscquad(Tstar,data));
<span class="keyword">else</span>
    disp(<span class="string">'Invalid Integration Type. Please check input file and try again.'</span>)
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> y = reducedviscint(Tstar)
<span class="comment">%REDUCEDVISCINT    Outputs the reduced viscosity integral.</span>
<span class="comment">%   Y=MY_REDUCEDVISCINT(TSTAR) generates a float array containing a value</span>
<span class="comment">%   for the exact reduced viscosity integral in Khrapak, S.A. Accurate</span>
<span class="comment">%   transport cross sections for the Lennard-Jones potential (2014).</span>
<span class="comment">%</span>
<span class="comment">%   -- TSTAR is  float array containing the reduced temperature values.</span>
y = zeros(size(Tstar));
ct = 1;
<span class="keyword">for</span> t = Tstar
redviscintegrand = @(x) 0.5*(x.^3).*exp(-x).*viscositycs(1./(2*t*x));
y(ct) = integral(redviscintegrand,0,Inf);
ct = ct + 1;
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> y = reducedviscquad(Tstar,data)
<span class="comment">%REDUCEDVISCQUAD    Outputs the reduced viscosity integral using quadrature.</span>
<span class="comment">%   Y=MY_REDUCEDVISCQUAD(TSTAR,DATA) generates a float array containing a value</span>
<span class="comment">%   for the reduced viscosity integral in Khrapak, S.A. Accurate transport</span>
<span class="comment">%   cross sections for the Lennard-Jones potential (2014) using trapezoidal</span>
<span class="comment">%   integration.</span>
<span class="comment">%</span>
<span class="comment">%   -- TSTAR is  float array containing the reduced temperature values.</span>
<span class="comment">%   -- DATA is a char array containing the filepath of the cross-section</span>
<span class="comment">%   data.</span>
y = zeros(size(Tstar));
ct = 1;
csdata = readmatrix(data);
<span class="keyword">for</span> t = Tstar
X = 1./(2*t*csdata(:,1));
redviscintegrand = -0.25*(X.^3).*exp(-X).*csdata(:,2)./(t*csdata(:,1).^2);
y(ct) = trapz(csdata(:,1),redviscintegrand);
ct = ct + 1;
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="viscositycs" style="margin-left: 20px;">viscositycs</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = viscositycs(beta)
<span class="comment">%VISCOSITYCS    Outputs float array with viscosity cross-section values.</span>
<span class="comment">%   Y=VISCOSITYCS(BETA) generates a float array containing viscosity</span>
<span class="comment">%   cros-section value for each value of the scattering parameter beta</span>
<span class="comment">%   using a Lennard_Jones potential.</span>
<span class="comment">%</span>
<span class="comment">%   -- BETA must be a float array containing values for the dimensionless</span>
<span class="comment">%   scattering parameter.</span>
<span class="comment">%</span>
<span class="comment">%   See also DIFFUSIONCS RUN_TRANSPORTCS</span>
fLEeta = 1;
fHEeta = 1 - 2.229.*(beta) + 35.967.*(beta.^(2)) - 86.490.*(beta.^(3)) <span class="keyword">...</span>
    + 60.335.*(beta.^(4));

y = zeros(size(beta));
<span class="comment">%%Case 1: beta &lt; 0.491</span>
idx1 = beta &lt; 0.491;
y(idx1) = 3.599.*(beta(idx1).^(1/6)).*fHEeta(idx1);

<span class="comment">%%Case 2: beta &gt; 0.491</span>
idx2 = beta &gt; 0.491;
y(idx2) = 7.480.*(beta(idx2).^(1/3))*fLEeta;
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="zbl" style="margin-left: 20px;">zbl</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = zbl(z1,z2,r)
<span class="comment">%ZBL    Outputs ZBL potential data.</span>
<span class="comment">%   Y=ZBL(Z1,Z2,R) generates a float array containing</span>
<span class="comment">%   a potential energy value for each r value using the ZBL potential.</span>
<span class="comment">%   Units of potential energy are eV.</span>
<span class="comment">%</span>
<span class="comment">%   -- Z1 must be the integer atomic number of species 1.</span>
<span class="comment">%   -- Z2 must be the integer atomic number of species 2.</span>
<span class="comment">%   -- R must be the numerical array containing r values in units of</span>
<span class="comment">%   Angstrom.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_CALCPOTENTIAL</span>
    eps_naught = 0.005526349406; <span class="comment">%e^2 * eV^-1 * Angstrom^-1</span>
    Ke = 4*pi*eps_naught;
    a = (0.46850)/(z1^(0.23) + z2^(0.23));
    y = phi(r/a).*z1*z2./(Ke.*r);
<span class="keyword">end</span>

<span class="keyword">function</span> y = phi(x)
    y = 0.18175*exp(-3.19980*x) + 0.50986*exp(-0.94229*x) + <span class="keyword">...</span>
        0.28022*exp(-0.40290*x) + 0.02817*exp(-0.20162*x);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="zblchar" style="margin-left: 20px;">zblchar</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = zblchar(z1)
<span class="comment">%ZBLCHAR    Outputs character array with fitting model.</span>
<span class="comment">%   Y=ZBLCHAR(Z1) generates a char array containing the ZBL potential</span>
<span class="comment">%   equation with the user-specified Z1.</span>
<span class="comment">%</span>
<span class="comment">%   -- Z1 must be the integer atomic number of species 1.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_FITPOTENTIAL</span>
    eps_naught = 0.005526349406; <span class="comment">%e^2 * eV^-1 * Angstrom^-1</span>
    Ke = 1/(4*pi*eps_naught);
    a = sprintf(<span class="string">'(0.46850)/((%i)^(0.23) + z2^(0.23))'</span>,z1);
    phi1 = sprintf(<span class="string">'0.18175*exp(-3.19980*x/(%s)) + 0.50986*exp(-0.94229*x/(%s))'</span>,a,a);
    phi2 = sprintf(<span class="string">'0.28022*exp(-0.40290*x/(%s)) + 0.02817*exp(-0.20162*x/(%s))'</span>,a,a);
    phi = [phi1 <span class="string">'+'</span> phi2];
    y = sprintf(<span class="string">"(%d)*(%s)*%i*z2./x"</span>,Ke,phi,z1);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div><hr/><h1 id="zblderivative" style="margin-left: 20px;">zblderivative</h1>
<div class="content">
<pre class="codeinput">
<span class="keyword">function</span> y = zblderivative(z1,z2,r)
<span class="comment">%ZBLDERIVATIVE    Outputs the derivative of a ZBL potential.</span>
<span class="comment">%   Y=ZBLDERIVATIVE(Z1,Z2,R) generates a float array containing</span>
<span class="comment">%   the derivative of the potential energy for each r value using the ZBL potential.</span>
<span class="comment">%   Units of potential energy are eV.</span>
<span class="comment">%</span>
<span class="comment">%   -- Z1 must be the integer atomic number of species 1.</span>
<span class="comment">%   -- Z2 must be the integer atomic number of species 2.</span>
<span class="comment">%   -- R must be the numerical array containing r values in units of</span>
<span class="comment">%   Angstrom.</span>
<span class="comment">%</span>
<span class="comment">%   See also RUN_CALCPOTENTIAL</span>
    eps_naught = 0.005526349406; <span class="comment">%e^2 * eV^-1 * Angstrom^-1</span>
    k = 1/(4*pi*eps_naught);
    a = (0.46850)/(z1^(0.23) + z2^(0.23));
    y = (-k*z1*z2./(r.^2))*(0.18175*exp(-3.19980*r/a) + 0.50986*exp(-0.94229*r/a) + <span class="keyword">...</span>
        0.28022*exp(-0.40290*r/a) + 0.02817*exp(-0.20162*r/a)) + <span class="keyword">...</span>
        (k*z1*z2./(r*a))*((0.18175*-3.19980)*exp(-3.19980*r/a) + (0.50986*-0.94229)*exp(-0.94229*r/a) + <span class="keyword">...</span>
        (0.28022*-0.40290)*exp(-0.40290*r/a) + (0.02817*-0.20162)*exp(-0.20162*r/a));
<span class="keyword">end</span>
</pre>
<p class="footer">
<br/>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB® R2024a</a>
<br/>
</p>
</div>
</body>
</html>


